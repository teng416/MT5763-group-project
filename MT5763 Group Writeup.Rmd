---
title: "MT5763 Group Project"
author: "Group Yojimbo"
date: "24/10/2018"
output: html_document
---
The new function uses a vectorised form of linear regression to produce the coefficients. The input data must have it's columns ordered "Intercept", "Covariates", "Dependent Variable", ie we have

Intercept | x1 | x2 | ... | y
----------|----|----|-----|---
1         | x11| x12| x1n | y1

and so on. From this we construct the matrix X which includes the intercept and covariates:

$$
\textbf{X} = \begin{pmatrix} 1 & x_{11} & x_{12}  & \cdots & x_{1n} \\
1 & x_{21} & x_{22}  & \cdots & x_{2n} \\
\vdots & \vdots & \vdots & \ddots & \vdots & \\
1 & x_{n1} & x_{n2} & \cdots & x_{nn}
\end{pmatrix}
$$
and the vector y that includes the dependent variable:

$$
y = \begin{pmatrix} y_{1} \\ y _{2} \\ \vdots \\ y_{n} \end{pmatrix}
$$
We wish to solve the matrix equation
$$
\textbf{X} z = y
$$
Where $z$ is a vector containing our regression coefficients, ie if we compute the first line of this calculation we find:

$$
z_{1} + z_{2}x_{11} + z_{3}x_{12} + \cdots + z_{n}x_{1n} = y_{1}
$$
Solving over the entire dataset gives us a good idea of what the values of $z_{i}$ are. R has the command solve() built in for exactly this type of problem, however solve() only works if $\textbf{X}$ is a square matrix. To remedy this, we multiply both sides of the equation by the transpose of $\textbf{X}$. This is what is being done using crossprod(). This obviously has no effect on the solutions $z_{i}$, it merely frames the problem in such a way that solve() is satisfied.

Having covered the mathematical framework, we now look at the code that actually does this.


```{r}

#Generating some random data to work with.
set.seed(1)
n <- 100
x <- runif(n)
y <- x + 1 + rexp(n)


#Data for use with vector needs to be ordered: Intercept, covariates, dependent variable.
data.m <- cbind("(Intercept)" = 1, x, y)
data.f <- data.frame(x,y)


#~~~~~~~~~~Vectorisation~~~~~~~~~~~~~~~~~~~~~~~~~

boot.lm.vector <- function(index, inputData) {
  
  #Random sampling from input data with replacement.
  d <- inputData[sample.int(nrow(inputData), replace = T),]
  
  #Define matrix with covariates and intercept.
  a <- ncol(inputData)-1
  X <- d[, 1:a]
  
  #Vector with dependent variable.
  y <- d[, a+1]
  
  #Solve for coefficients. Solve requires square matrix, hence use of crossprod
  solve(crossprod(X), crossprod(X,y))
}

#Non parallel method of repeating bootstraps, still produces very respectable times.

system.time(r1 <- t(replicate(10000, boot.lm.vector(1, data.m))[,1,]))

#a <- c(mean(r1[,1]), mean(r1[,2]))
#a
```

```{r}
#~~~~~~~~~~~~~~~~Parallelising~~~~~~~~~~~~~~~~~~~~~

library(parallel)
library(doParallel)
nCores <- detectCores()
myClust <- makeCluster(nCores-1, type = "PSOCK")


system.time(rtest <- parLapply(myClust, 1:10000, fun = boot.lm.vector, inputData = data.m)) 



```

